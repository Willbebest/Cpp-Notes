#### 内存对齐

***

在工作中一直与协议的存储和传输数据打交道，每当结构体中没有指针指向的动态地址，又想偷懒时，就会使用内存对齐过的结构体读取数据。

**内存对齐**是指计算机系统为了提高存储效率，要求对象的地址必须是K(2/4/8)的倍数。

**原因**：为了让内存存取的效率更高，所以在编译阶段采取的优化内存存取的手段。以 int 型数据为例，如果他在内存的位置按 4 个字节对齐，也就是说 1 个 int 的数据全部落在计算机一次取数的区间内，那么只需一次存取就可以。如果对齐的字节数小于 4 个字节，那 int 类型会跨越取数的边界，需要两次才能全部取出，效率降低。

**对齐原则**：

- <u>结构体内成员按自身长度自对齐</u>：自身长度，如 char=1，short=2，int=4，double=8。所谓的自对齐，指的是该成员的起始位置的内存地址必须是它自身长度的整数倍。如 int 只能以 0，4，8这类地址开始。

- <u>结构体的总大小为结构体的有效对齐值得整数倍</u>：结构体的有效对齐值的确定
  -  当未明确指定时，以结构体中最长的成员的长度为其有效值
  - 当用`#pragma pack(n)` 指定时，以 `n` 和结构体中最长成员的长度中较小者为其值。
  - 当用`__attribute__((__packed__))`指定长度时，强制按照此值为结构体的有效长度。

**内存对齐的汇编指令**：`.align 8`

***

**是否可以使用`memcmp`比较结构体的大小？如果并不可以，如何比较？**

答：不能使用`memcmp`对结构体进行字节比较。因为结构体在编译阶段会进行内存对齐。会导致出现"内存空洞"，无法预料“空洞”内存包含的值。`memcmp`用于指出两个指针所指内存中前 n 个字节中所存的数据是否相等。当在定义变量时，全局变量和`static`变量会自动初始化为0。局部变量的值不确定，必须先赋值再使用。我们无法保证填充字节中是什么数据。

① 如果一定要`memcmp`进行比较需要修改有效对其长度为1：`#pragma pack(1)`

② 可以成员逐一比较。

③ 可以使用`memset`进行所有字节赋值为0，然后再用`memcmp`比较。
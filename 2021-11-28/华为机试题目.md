## 华为机试题目

#### 1、找朋友

**【题目描述】**

在学校中，`N` 个⼩朋友站成⼀队， 第 `i `个⼩朋友的身⾼为 `height[i]`， 第 `i`个⼩朋友可以看到的第⼀个⽐⾃⼰身⾼更⾼的⼩朋友`j`，那么 `j` 是` i` 的好朋友(要求 `j`  > `i`)。
请重新⽣成⼀个列表，对应位置的输出是每个⼩朋友的好朋友位置，如果没有看到好朋友，请在该位置⽤ 0 代替。
注：⼩朋友⼈数范围是 [0, 40000]。

**输入描述：**

> 第⼀⾏输⼊N，N表示有N个⼩朋友 第⼆⾏输⼊N个⼩朋友的身⾼height[i]，都是整数

**输出描述：**

> 输出N个⼩朋友的好朋友的位置

**示例说明：**

示例一：

> 输入：
>
> 2
>
> 100   95
>
> 输出：
>
> 0    0

示例二：

> 输入：
>
> 8
>
> 123 124 125 121 119 122 126 123 
>
> 输出：
>
> 1 2 6 5 5 6 0 0

**【解法】**

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	int len = 0;
	while(cin>>len) {
        // input heights
		vector<pair<int, int>> heights(len, {0,0});
		for (int i = 0; i < len; i++) {
			cin >> heights[i].first;
		}
		// compute
		for (int i = 0; i < len; i++) {
			for (int j = i + 1; j < len; j++) {
				if (heights[j].first > heights[i].first) {
					heights[i].second = j;
					break;
				}
			}
		}
		// output
		for (int i = 0; i < len; i++) {
			cout << heights[i].second << " ";
		}
		cout << endl;
	}

	return 0;
}
```

**【其它】**

有人说可以使用栈来做



#### 2、寻找最短子串

**【题目描述】**

给定两个字符串 `str1` 和`str2`，`str1`进行排列组合只要有一个为`str2`的子串则认为`str1`是`str2`的关联子串，请返回子串在`str2`的起始位置，若不是关联子串则返回 -1.

示例：

示例一：

> 输入：
>
> abc efghicbaiii
>
> 输出：
>
> 5

示例二：

> 输入：
>
> abc efghiccaiii
>
> 输出：
>
> -1

**思路：**

把str1弄成map,键为字母，值为个数。然后遍历str2,先复制这个map,然后每个字母去map里面匹配，如果存在，value减1，如果不存在或者减1会变成负数，重新复制map。继续下一个。当然，还要维护一个n=str1.length,如果str2匹配了n次都顺利，那就找到了。

**【解法】**

```cpp
#include <iostream>
#include <string>
#include <unordered_map> 

using namespace std;

int main()
{
	string str1, str2;
	while (cin >> str1 >> str2) {
		int ret = -1;
		int len1 = str1.size();
		int len2 = str2.size();
		if (len1 > len2) {
			cout << -1 << endl;
			continue;
		}

		unordered_map<char, int> counter;
		for (int i = 0; i < len1; i++) {
			counter[str1[i]]++;
		}

		for (int i = 0; i < len2 - len1; i++) {
			unordered_map<char, int> temp = counter;
			for (int j = i; j < i + len1; j++) {
				if (temp.count(str2[j])) {
					temp[str2[j]]--;
				} else {
					break;
				}
				if (temp[str2[j]] == 0) {
					temp.erase(str2[j]);
				}
			}
			if (temp.empty()) {
				ret = i;
				break;
			}
		}

		cout << ret << endl;
	}

	return 0;
}
```



####  3、机器调度

**【题目描述】**

> 输入M表示一共有M组任务。
>
> 输入N表示一共有n个机器，每个机器都有配置时间B和工作时间J。需要在配置完机器后，才可以开始工作。两个机器可以同时进行工作，但不能同时配置。
>
> 求怎么在最短时间内做完所有工作

**示例**：

示例一：

> 输入：
>
> 1
>
> 1
>
> 2 2
>
> 输出：
>
> 4
>
> 解释：第一行1为一组任务，第二行1代表只有一台机器，第三行表示该机器配置需2分钟，执行需2分钟

示例二：

> 输入：
>
> 2
>
> 2
>
> 1 1
>
> 2 2
>
> 3
>
> 1 1
>
> 2 2
>
> 3 3
>
> 输出：
>
> 4
>
> 7
>
> 解释：
>
> 第一行2代表两组任务，
>
> 第二行2代表第一组任务有2个机器，
>
> 第三行1 1代表机器1配置需要1分运行需要1分，
>
> 第四行2 2代表机器2配置需要2分运行需要2分，
>
> 第五行3代表第二组任务需要3个机器，
>
> 第6-8行分别表示3个机器的配置与运行时间

**思路**：思路优先执行运行时间长的机器

【解法】

```cpp
#include <map>
#include <iostream>
#include <vector>

using namespace std;

struct classcomp {
	bool operator() (int a, int b) const {
		return a > b;
	}
};

int main()
{
	int task = 0;
	while (cin >> task) {
		if (task <= 0)continue;
		vector<map<int, int, classcomp>>  buffer(task);
		for (int i = 0; i < task; i++) {
			int machine = 0;
			cin >> machine;
			for (int j = 0; j < machine; j++) {
				int time1, time2;
				if (cin >> time1 >> time2) {
					buffer[i][time2] = time1;
				}
			}
		}

		for (int i = 0; i < task; i++) {
			auto iter = buffer[i].begin();
			int res = iter->first + iter->second;
			int pre = iter->first;
			iter++;
			while (iter != buffer[i].end()) {
				res = res - pre + iter->first + iter->second;
				pre = iter->first;
				iter++;
			}
			cout << res << endl;
		}
	}

	return 0;
}
```



#### 4、求最大值

**【题目描述】**

> 输入一个数M，表示数组中有M个数
>
> 输入M个数
>
> 输入 n
>
> 求数组M中，去除重复值后的，最大值和最小值的和\
>
> 注意：最大和最小的数中不能有重复值，否则输出 -1

**示例：**

示例一

> 输入：
>
> 5
>
> 3  3  2  4 2
>
> 2
>
> 输出：
>
> -1
>
> 说明：去除重复后最大的2个数[4,3]，最小的两个数[2,3]，有相同值，所以返回 -1

示例二：

> 输入：
>
> 5
>
> 3 3 2 4 2
>
> 2
>
> 输出：
>
> -1
>
> 说明：去除重复后最大的1个数是[4]，最小的1个数为[2]，没有相同值，返回6

**【解法】**

```cpp
#include <set>
#include <iostream>

using namespace std;

int main()
{
	int count = 0;
	while (cin >> count) {
		set<int> nums;
		for (int i = 0; i < count; i++) {
			int temp = 0;
			cin >> temp;
			nums.insert(temp);
		}
		int n = 0;
		cin >> n;

		if (nums.size() < n * 2) {
			cout << -1 << endl;
			continue;
		}

		auto iter = nums.begin();
		auto rIter = nums.rbegin();
		int sum = 0;
		for (int i = 0; i < n; i++) {
			sum += *iter + *rIter;
			iter++;
			rIter++;
		}
		cout << sum << endl;
	}

	return 0;
}
```

#### 5、打印序列

**【题目描述】**

编写程序，输入打印序列，按优先级输出实际打印顺序

某个打印机根据打印序列执行打印任务，打印任务有9个级别，用1~9表示，数字越大优先级越高，打印机每次从队列头部去一个任务A，然后检查队列余下任务中有没有比A优先级更高的任务。若有，则将A放回队列尾部，否则执行A的打印，请编写程序，根据输入打印队列，输出实际打印顺序。

> 输入描述：
>
> 输入一行，表示每个任务优先级，优先级之间用逗号隔开
>
> 输出描述：
>
> 输出每个打印序列，从0开始，用逗号隔开

**示例：**

示例一

>输入：
>
>9,  3 ,  5
>
>输出：
>
>0,   2,   1

示例二

> 输入：
>
> 1,  2,  2
>
> 输出：
>
> 2,  0,  1



#### 6、句子的平均质量

【题目描述】

> 每个句子由多个单词组成，句子中的每个单词的长度都可能不一样，我们假设每个单词的长度Ni为该单词的重量，你需要做的就是给出整个句子的平均重量V。
>
>  解答要求: 
>
>  	时间限制：1000ms, 内存限制：64MB
>
> 输入：
>
> ​	输入只有一行，包含一个字符串S(长度不会超过100)，代表整个句子，句子中只包含大小写的英文字母，每个单词之间有一个空格。
>
> 输出：
>
> ​	输出 输出句子S的平均重量V(四舍五入保留两位小数)。

示例：

> 输入：
>
> Who Love Solo
>
> 输出：
>
> 3.67

【解法】

```cpp
#include <sstream>
#include <iostream>
#include <cstdio>
using namespace std;

int main() {
	string line;
	while (getline(cin, line)) {
		stringstream ss(line);
		int sum = 0;
		int count = 0;
		string word;
		while (ss >> word) {
			sum += word.size();
			count++;
		}
		//cout << (double)sum / (double)count << endl;
		printf("%.2f", (double)sum / (double)count);
	}

	return 0;
}
```



#### 7、篮球赛

**【题目描述】**

十个人，每个人有一个战斗力 n1~n10， 分成两组（人数相同），战斗力差值最小。返回两队战斗力最小差值。

示例：

> 输入：
>
> 1 2 3 4 5 6 7 8 9 10
>
> 1

**【解法】**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int minValue = INT_MAX;
// dfs全排列 每次计算前5个 和后5个的绝对值差值 取最小的
void dfs(vector<int>& nums, vector<int>& path, vector<bool>& used) {
	if (path.size() == nums.size()) {
		int diff = abs(path[0] + path[1] + path[2] + path[3] + path[4] -
                       path[5] - path[6] - path[7] - path[8] - path[9]);
		minValue = min(minValue, diff);
		return;
	}
	for (int i = 0; i < nums.size(); i++) {
		// 剪枝，判断重复使用的数字
		if (used[i]) continue;
		path.push_back(nums[i]);
		used[i] = true;
		dfs(nums, path, used);
		// 回溯的过程中，将当前的节点从 path 中删除
		path.pop_back();
		used[i] = false;
	}
}

int main()
{
	vector<int> nums(10);
	for (int i = 0; i < 10; i++) {
		cin >> nums[i];
	}
	vector<int> path;
	vector<bool> used(10, false);
	dfs(nums, path, used);
	cout << minValue << endl;

	return 0;
}
```

8、求最长连续子数列

【题目描述】

给你一个数列 nums，再给你一个目标值 target，求nums中和为target的最长连续子数列。

示例：

> 输入：
>
> 1 2 3 4 2
>
> 6
>
> 输出：
>
> 3

【解法】

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maxLength(vector<int>& nums, int target) {
	if (nums.empty()) return 0;
	int res = 0;
	int maxlen = 0;
	int curSum = 0;
	int curlen = 0;
	for (int i = 0; i < nums.size(); i++) {
		if (curSum < target) {
			curSum += nums[i];
			curlen++;
		}

		if (curSum == target) {
			maxlen =  max(maxlen, curlen);
		}
		while (curSum >= target) {
			curSum -= nums[i-curlen+1];
			curlen--;
		}
	}

	return maxlen;
}

int main()
{
	int len=0;	
	int target=0;

	cin >> len;
	if (len <= 0) return -1;

	vector<int> nums(len);
	for (int i = 0; i < len; i++) {
		cin >> nums[i];
	}

	cin >> target;
	cout << maxLength(nums, target) << endl;

	return 0;

}
```

#### 9 进制数相减

**【题目描述】**

给定两个数进行相减，使用2~35进制中的一种表示。大于10进制的用a-z（小写字母）补齐。

输入描述：

>  输入三个数分别为 进制、使用指定进制表示的被减数、使用指定进制表示的减数

输出描述：

> 输出结果符号（0为正数，1为负数）     使用指定进制表示的结果

示例：

> 输入：
>
> 2   11  1
>
> 2 为2进制， 11 为被减数  1 为减数
>
> 输出：
>
> 0 10
>
> 解释：①0为正数，1为负数 ②11-1 =10

**【解法】**

```cpp
#include <iostream>
#include <string>
#include <cstring>

using namespace std;

//int convertToNum(char c) {
//	int base = 0;
//	if (isdigit(c)) {
//		base = c - '0';
//	}
//	else if (isalpha(c)) {
//		base = c - 'a' + 10;
//	}
//	return base;
//}
//
//int getValue(string s, int a) {
//	int res = 0;
//	int base = 1;
//	for (int i = s.size() - 1; i >= 0; i--) {
//		res += convertToNum(s[i]) * base;
//		base *= a;
//	}
//
//	return res;
//}

int getValue(string s, int a) {
	int res = 0;
	int base = 1;
	for (int i = s.size() - 1; i >= 0; i--) {
		int cur = 0;
		if (isdigit(s[i])) {
			cur = s[i] - '0';
		}
		else if (isalpha(s[i])) {
			cur = s[i] - 'a' + 10;
		}

		res += cur * base;
		base *= a;
	}

	return res;
}


string intToA(int n, int radix)    //n是待转数字，radix是指定的进制
{
	string ans = "";
	do {
		int t = n % radix;
		if (t >= 0 && t <= 9)	ans += t + '0';
		else ans += t - 10 + 'a';
		n /= radix;
	} while (n != 0);	//使用do{}while（）以防止输入为0的情况
	reverse(ans.begin(), ans.end());
	return ans;
}

int main()
{
	int base;
	string str1, str2;
	cin >> base >> str1 >> str2;

	int flag = 0;
	int num1 = getValue(str1, base);
	int num2 = getValue(str2, base);
	flag = (num1 >= num2) ? 0 : 1;
	string res = intToA(num1 - num2, base);
	cout << flag << " " << res << endl;

	return 0;
}
```

#### 10、求三个矩形的相交面积

**【题目描述】**

求三个矩形的相交面积

> 输入：
>
> 1 6 4 4
>
> 2 5 3 3
>
> 0 3 5 5
>
> 解释：三行为三个矩形，第一二列为左上角 横纵坐标，第三四列分别为矩形长宽
>
> 输出：
>
> 3
>
> 解释：
>
> 矩形面积

**【解法】**

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

struct Rect {
	int x;
	int y;
	int w;
	int h;
};

bool IsCross(const Rect& r1, const Rect& r2)
{
	if (r1.y < r2.y - r2.h || r2.y < r1.y - r1.h || r1.x + r1.w < r2.x || r2.x + r2.w < r1.x) {
		return false;
	} else {
		return true;
	}
}

Rect CrossRect(const Rect &r1, const Rect &r2)
{
	Rect res;
	int max_x = max(r1.x, r2.x);
	int min_y = min(r1.y, r2.y);
	int min_x = min(r1.x+r1.w, r2.x+r2.w);
	int max_y = max(r1.y-r1.w, r2.y-r2.w);

	res.x = max_x;
	res.y = min_y;
	res.w = min_x - max_x;
	res.h = min_y - max_y;

	return res;
}

int Compute(const Rect &rectA, const Rect &rectB, const Rect &rectC)
{
	if (!(IsCross(rectA, rectB) && IsCross(rectA, rectC) && IsCross(rectB, rectC))) {
		return 0;
	}

	Rect ans = CrossRect(rectA, rectB);
	Rect ans1 = CrossRect(ans, rectC);

	return ans1.w * ans1.h;
}

int main()
{
	Rect a, b,c;
	cin >> a.x >> a.y >> a.w >> a.h;
	cin >> b.x >> b.y >> b.w >> b.h;
	cin >> c.x >> c.y >> c.w >> c.h;

	cout << Compute(a, b, c) << endl;

	return 0;
}
```



















